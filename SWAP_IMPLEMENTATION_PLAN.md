# План реализации функционала выполнения свопов

## Обзор
Расширение существующего инструмента для котировок Raydium V4 AMM с добавлением возможности выполнения свопов непосредственно через блокчейн Solana.

## Фаза 1: Управление приватным ключом и инициализация кошелька

### Задачи:
1. Добавить загрузку приватного ключа из переменной окружения `SOLANA_PRIVATE_KEY`
2. Создать функцию для инициализации кошелька из приватного ключа
3. Добавить валидацию ключа при запуске программы
4. Реализовать безопасную обработку ошибок при отсутствии ключа

### Технические детали:
- Использовать `solana.PrivateKeyFromBase58()` для парсинга ключа
- Проверять корректность ключа через создание публичного ключа
- При отсутствии ключа выдавать понятное сообщение об ошибке

### Deliverables:
- [ ] Функция `loadWallet()` для загрузки кошелька
- [ ] Обновлённая функция `main()` с проверкой наличия ключа
- [ ] Документация по настройке переменной окружения

## Фаза 2: Интерактивное подтверждение котировки

### Задачи:
1. После расчёта котировки показать детальную информацию о свопе
2. Реализовать интерактивный запрос подтверждения (y/n)
3. При отказе - завершить программу
4. При подтверждении - перейти к запросу slippage

### Технические детали:
- Использовать `bufio.Scanner` для чтения пользовательского ввода
- Показать: входящую сумму, ожидаемую выходящую сумму, цену, комиссию
- Форматировать числа для удобства чтения

### Deliverables:
- [ ] Функция `confirmQuote()` для интерактивного подтверждения
- [ ] Улучшенный вывод информации о котировке

## Фаза 3: Ввод и обработка slippage

### Задачи:
1. Запросить у пользователя максимальный slippage в процентах
2. Валидировать введённое значение (0-100%)
3. Рассчитать минимальную выходящую сумму с учётом slippage
4. Показать пользователю финальные параметры свопа

### Технические детали:
- Slippage по умолчанию: 0.5%
- Формула: `minAmountOut = expectedOut * (1 - slippage/100)`
- Использовать `big.Int` для точных вычислений

### Deliverables:
- [ ] Функция `getSlippageFromUser()` для ввода slippage
- [ ] Функция `calculateMinAmountOut()` для расчёта минимальной суммы

## Фаза 4: Построение инструкции свопа для Raydium

### Задачи:
1. Изучить структуру инструкции свопа Raydium V4
2. Создать структуры данных для инструкции
3. Реализовать сериализацию инструкции
4. Добавить расчёт направления свопа (base->quote или quote->base)

### Технические детали:
- Инструкция свопа имеет тип 9 в Raydium V4
- Параметры: amountIn, minAmountOut, direction
- Использовать `github.com/gagliardetto/binary` для сериализации инструкций
- Этот пакет обеспечивает корректную сериализацию для Solana

### Структуры данных:
```go
type SwapInstructionData struct {
    Instruction   uint8  // = 9 for swap
    AmountIn      uint64
    MinAmountOut  uint64
}
```

### Deliverables:
- [ ] Структура `SwapInstructionData`
- [ ] Функция `createSwapInstruction()` для создания инструкции

## Фаза 5: Управление токен-аккаунтами (ATA)

### Задачи:
1. Проверить существование ATA для входящего и исходящего токенов
2. При необходимости создать инструкцию для создания ATA
3. Добавить инструкции в транзакцию в правильном порядке

### Технические детали:
- Использовать SPL Associated Token Account Program
- ATA адрес вычисляется детерминистически
- Для WSOL всегда нужен ATA

### Deliverables:
- [ ] Функция `getOrCreateATA()` для управления ATA
- [ ] Интеграция создания ATA в процесс построения транзакции

## Фаза 6: Построение и отправка транзакции

### Задачи:
1. Собрать все инструкции в одну транзакцию
2. Получить свежий blockhash
3. Подписать транзакцию приватным ключом
4. Отправить транзакцию в сеть
5. Дождаться подтверждения

### Технические детали:
- Добавить приоритетную комиссию для ускорения
- Использовать `SendTransactionWithOpts` с параметром `SkipPreflight: false`
- Таймаут ожидания подтверждения: 30 секунд

### Deliverables:
- [ ] Функция `executeSwap()` для выполнения свопа
- [ ] Обработка ошибок транзакции

## Фаза 7: Парсинг результатов транзакции

### Задачи:
1. Получить детали подтверждённой транзакции
2. Парсить логи для извлечения фактических сумм свопа
3. Рассчитать фактическую цену исполнения
4. Определить реальный slippage

### Технические детали:
- Использовать `GetTransaction()` для получения деталей
- Парсить pre/post балансы токен-аккаунтов
- Искать в логах события Raydium

### Deliverables:
- [ ] Функция `parseSwapResult()` для парсинга результатов
- [ ] Структура `SwapResult` с фактическими данными

## Фаза 8: Генерация финального отчёта

### Задачи:
1. Создать структуру для отчёта о транзакции
2. Вывести все ключевые метрики свопа
3. Показать ссылку на эксплорер
4. Рассчитать и показать итоговый slippage

### Структура отчёта:
```go
type TransactionReport struct {
    TxHash           string
    Status           string
    AmountIn         float64
    AmountOut        float64
    ExpectedPrice    float64
    ActualPrice      float64
    Slippage         float64
    ExplorerURL      string
}
```

### Deliverables:
- [ ] Функция `generateReport()` для создания отчёта
- [ ] Красивый вывод отчёта в консоль

## Дополнительные соображения

### Ограничения:
1. **Только WSOL** - пользователь должен предварительно обернуть SOL
2. **Helius RPC** - требуется для надёжной работы
3. **Без защиты от MEV** - транзакции могут быть frontrun
4. **Только Raydium V4** - другие версии не поддерживаются

### Рекомендуемые библиотеки:
- `github.com/gagliardetto/solana-go` - основная библиотека (уже используется)
- `github.com/gagliardetto/binary` - для сериализации инструкций Solana
- `github.com/shopspring/decimal` - для точных вычислений
- Стандартная библиотека Go для остального функционала

### Безопасность:
- Никогда не логировать приватный ключ
- Использовать переменные окружения для чувствительных данных
- Валидировать все пользовательские вводы
- Проверять балансы перед выполнением свопа

## Порядок выполнения

Рекомендуется выполнять фазы последовательно, тестируя каждую перед переходом к следующей:

1. Фаза 1-3: Базовая инфраструктура и пользовательский интерфейс
2. Фаза 4-6: Построение и выполнение транзакции
3. Фаза 7-8: Обработка результатов и отчётность

Каждая фаза может быть протестирована независимо на devnet перед использованием на mainnet.